"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = errorManager;
exports.isValidationError = void 0;

var _Errors = require("./Errors");

var _errToJSON = _interopRequireDefault(require("./utils/errToJSON"));

var _paths = require("./utils/paths");

var _uniqBy = _interopRequireDefault(require("lodash/uniqBy"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function trimChildren(rootPath, errors) {
  let result = {};
  Object.keys(errors).forEach(path => {
    if (rootPath !== path && (0, _paths.inPath)(rootPath, path)) return;
    result[path] = errors[path];
  });
  return result;
}

function reduce(paths) {
  paths = (0, _uniqBy.default)(paths, p => p.path);
  if (paths.length <= 1) return paths;
  return paths.reduce((innerPaths, current) => {
    innerPaths = innerPaths.filter(p => !(0, _paths.inPath)(current.path, p.path));
    if (!innerPaths.some(p => (0, _paths.inPath)(p.path, current.path))) innerPaths.push(current);
    return innerPaths;
  }, []);
}

let isValidationError = err => err && err.name === 'ValidationError';

exports.isValidationError = isValidationError;

function errorManager(handleValidation) {
  return {
    async collect(paths, pristineErrors = _Errors.EMPTY_ERRORS, options) {
      const specs = reduce(paths.map(p => typeof p === 'string' ? {
        path: p,
        shallow: false
      } : p));
      let errors = Object.assign({}, pristineErrors);
      let nextErrors = errors;
      let workDone = false;
      specs.forEach(({
        path,
        shallow
      }) => {
        nextErrors = (0, _paths.trim)(path, nextErrors, shallow);
        if (errors !== nextErrors) workDone = true;
      });
      let validations = specs.map(spec => Promise.resolve(handleValidation(spec, options)).then(validationError => {
        if (!validationError) return true;
        if (!isValidationError(validationError)) throw validationError;

        if (!spec.shallow) {
          (0, _errToJSON.default)(validationError, nextErrors);
          return;
        }

        const fieldErrors = (0, _errToJSON.default)(validationError);
        Object.assign(nextErrors, trimChildren(spec.path, fieldErrors));
      }));
      const results = await Promise.all(validations);
      if (!workDone && results.every(Boolean)) return pristineErrors;
      return nextErrors;
    }

  };
}