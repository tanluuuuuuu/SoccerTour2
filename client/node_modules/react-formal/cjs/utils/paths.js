"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clean = clean;
exports.inPath = inPath;
exports.isQuoted = isQuoted;
exports.reduce = reduce;
exports.toArray = void 0;
exports.trim = trim;

var _uniq = _interopRequireDefault(require("lodash/uniq"));

var _propertyExpr = _interopRequireDefault(require("property-expr"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const toArray = arr => {
  const next = [];
  return arr == null ? next : next.concat(arr);
};

exports.toArray = toArray;

function isQuoted(str) {
  return typeof str === 'string' && str && (str[0] === '"' || str[0] === "'");
}

function clean(part) {
  return isQuoted(part) ? part.substr(1, part.length - 2) : part;
}

function inPath(basePath, childPath) {
  if (basePath === childPath) return true;
  let partsA = _propertyExpr.default.split(basePath) || [];
  let partsB = _propertyExpr.default.split(childPath) || [];
  if (partsA.length > partsB.length) return false;
  return partsA.every((part, idx) => clean(part) === clean(partsB[idx]));
}

function reduce(paths) {
  paths = (0, _uniq.default)(toArray(paths));
  if (paths.length <= 1) return paths;
  return paths.reduce((paths, current) => {
    paths = paths.filter(p => !inPath(current, p));
    if (!paths.some(p => inPath(p, current))) paths.push(current);
    return paths;
  }, []);
}

function trim(rootPath, pathHash, exact = false) {
  let workDone = false;
  let result = {};
  let matches = exact ? p => p === rootPath : p => inPath(rootPath, p);
  Object.keys(pathHash).forEach(path => {
    if (matches(path)) {
      return workDone = true;
    }

    result[path] = pathHash[path];
  });
  return workDone ? result : pathHash;
}