"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _useFieldArray = _interopRequireDefault(require("./useFieldArray"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/**
 * `<FieldArray>`, unlike `<Field>`, does not render any component, and
 * is essentially a render prop version of [`useFieldArray`](/api/useFieldArray), accepting all
 * the same options.
 *
 * @memberof Form
 */
function FieldArray(_ref) {
  let {
    children
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, ["children"]);

  const [values, arrayHelpers, meta] = (0, _useFieldArray.default)(props);
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, children(values, arrayHelpers, meta));
}

FieldArray.displayName = 'FieldArray'; // @ts-ignore

FieldArray.propTypes = {
  name: _propTypes.default.string.isRequired,

  /**
   * The similar signature as providing a function to `<Field>` but with an
   * additional `arrayHelpers` object passed to the render function:
   *
   * ```tsx static
   * <Form.FieldArray>
   *   {(values, arrayHelpers, meta) => ... }
   * </Form.FieldArray>
   * ```
   *
   * @type {(value: T, arrayHelpers: FieldArrayHelpers, meta; FieldMeta) => ReactNode}
   */
  children: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.element])
};
var _default = FieldArray;
exports.default = _default;