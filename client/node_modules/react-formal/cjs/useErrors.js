"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = require("react");

var _Contexts = require("./Contexts");

var _memoizeOne = _interopRequireDefault(require("memoize-one"));

var _shallowequal = _interopRequireDefault(require("shallowequal"));

var _Errors = require("./Errors");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isFilterErrorsEqual([a], [b]) {
  let isEqual = (a.errors === b.errors || (0, _shallowequal.default)(a.errors, b.errors)) && a.names === b.names && a.mapErrors === b.mapErrors;
  return isEqual;
}
/**
 * Returns the field errors for the form, or a subset of field errors if paths is provided.
 *
 * @param paths a path or set of paths to retrieve errors for.
 * @param options
 * @param {boolean=} options.inclusive By default, only errors with exact matches on each path are returned.
 *  Set to `false` to also return errors for a path and any nested paths
 *
 * @returns {Errors}
 */


function useErrors(paths, {
  inclusive
} = {}) {
  const errors = (0, _Contexts.useFormContext)(_Contexts.BITS.errors).errors;
  const memoFilterAndMapErrors = (0, _react.useMemo)(() => (0, _memoizeOne.default)(_Errors.filterAndMapErrors, isFilterErrorsEqual), []);
  return paths ? memoFilterAndMapErrors({
    errors,
    names: paths,
    mapErrors: !inclusive ? undefined : _Errors.inclusiveMapErrors
  }) : errors;
}

var _default = useErrors;
exports.default = _default;